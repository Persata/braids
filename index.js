// Generated by CoffeeScript 1.7.1
(function() {
  var Braids, Promise, exec, execPromisified, extend, fileSizeConversions, fileSizeRegex, humanizeBytes, humanizeDivisions, mimeTypeRegex, mimeTypeWildcardRegex, sizeInBytes, _,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ = require('lodash');

  _.str = require('underscore.string');

  Promise = require('bluebird');

  exec = require('child_process').exec;

  execPromisified = Promise.promisify(exec);

  extend = function(protoProps, staticProps) {
    var Surrogate, child, parent;
    parent = this;
    child = void 0;
    if (protoProps && _.has(protoProps, 'constructor')) {
      child = protoProps.constructor;
    } else {
      child = function() {
        return parent.apply(this, arguments);
      };
    }
    _.extend(child, parent, staticProps);
    Surrogate = function() {
      this.constructor = child;
    };
    Surrogate.prototype = parent.prototype;
    child.prototype = new Surrogate;
    if (protoProps) {
      _.extend(child.prototype, protoProps);
    }
    child.__super__ = parent.prototype;
    return child;
  };

  fileSizeConversions = {
    k: 1024,
    K: 1024,
    kb: 1024,
    KB: 1024,
    kB: 1024,
    m: Math.pow(1024, 2),
    M: Math.pow(1024, 2),
    MB: Math.pow(1024, 2),
    g: Math.pow(1024, 3),
    G: Math.pow(1024, 3),
    GB: Math.pow(1024, 3)
  };

  humanizeDivisions = [];

  humanizeDivisions[1024] = 'kB';

  humanizeDivisions[Math.pow(1024, 2)] = 'MB';

  humanizeDivisions[Math.pow(1024, 3)] = 'GB';

  fileSizeRegex = /(\d+)(\D+)/i;

  mimeTypeWildcardRegex = /(\D+)\/(\*)/i;

  mimeTypeRegex = /(\D+)\/(\D+)/i;

  sizeInBytes = function(sizeString) {
    var jedecDenomination, numericValue, regexResult;
    regexResult = fileSizeRegex.exec(sizeString);
    if (regexResult) {
      numericValue = regexResult[1];
      jedecDenomination = regexResult[2];
      if ((!isNaN(parseFloat(numericValue))) && fileSizeConversions[jedecDenomination]) {
        return numericValue * fileSizeConversions[jedecDenomination];
      }
    } else if ((regexResult === null) && (!isNaN(parseInt(sizeString)))) {
      return sizeString;
    }
    throw new Error('Unable to parse the maximum file size supplied - use either a number, or JEDEC denomination under 1TB, e.g. 2M, 120kB');
  };

  humanizeBytes = function(bytesAmount) {
    var divideAmount, humanString;
    for (divideAmount in humanizeDivisions) {
      humanString = humanizeDivisions[divideAmount];
      if ((bytesAmount / divideAmount) < 1024) {
        return (bytesAmount / divideAmount) + humanString;
      }
    }
    return bytesAmount + ' bytes';
  };

  Braids = (function() {
    function Braids() {}

    Braids.joi = require('joi');

    Braids.Model = (function() {
      Model.prototype.name = null;

      Model.prototype.fields = [];

      Model.prototype.labels = [];

      Model.prototype.joiValidators = [];

      Model.prototype.customValidators = [];

      Model.prototype.fileValidators = [];

      Model.prototype.errorMessages = [];

      function Model() {
        this._fileValidate = __bind(this._fileValidate, this);
        this._validateArrayOfCustomValidators = __bind(this._validateArrayOfCustomValidators, this);
        this._customValidate = __bind(this._customValidate, this);
        this._joiValidate = __bind(this._joiValidate, this);
        this.fieldIdentifier = __bind(this.fieldIdentifier, this);
        this.getContainerClasses = __bind(this.getContainerClasses, this);
        this.getLabelText = __bind(this.getLabelText, this);
        this.getErrorsForField = __bind(this.getErrorsForField, this);
        this.getAllErrors = __bind(this.getAllErrors, this);
        this.addError = __bind(this.addError, this);
        this.validate = __bind(this.validate, this);
        this.parseRequestAttributes = __bind(this.parseRequestAttributes, this);
        this.getValues = __bind(this.getValues, this);
        this.setValues = __bind(this.setValues, this);
        this.setFieldValue = __bind(this.setFieldValue, this);
        this.getFieldValue = __bind(this.getFieldValue, this);
        var field, _i, _len, _ref;
        if (this.name == null) {
          throw new Error('You Must Specify A Name For This Model');
        }
        _ref = this.fields;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          field = _ref[_i];
          this[field] = '';
        }
      }

      Model.prototype.getFieldValue = function(field) {
        return this[field];
      };

      Model.prototype.setFieldValue = function(field, value) {
        return this[field] = value;
      };

      Model.prototype.setValues = function(values) {
        var field, _i, _len, _ref;
        _ref = this.fields;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          field = _ref[_i];
          if (values[field]) {
            this[field] = values[field];
          }
        }
        return this;
      };

      Model.prototype.getValues = function() {
        var field, values, _i, _len, _ref;
        values = {};
        _ref = this.fields;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          field = _ref[_i];
          values[field] = this[field];
        }
        return values;
      };

      Model.prototype.parseRequestAttributes = function(request) {
        var fieldKey, parameterKey, parameterValue, _ref, _ref1;
        _ref = request.body;
        for (parameterKey in _ref) {
          parameterValue = _ref[parameterKey];
          fieldKey = parameterKey.replace(this.name + '_', '');
          if (__indexOf.call(this.fields, fieldKey) >= 0) {
            this.setFieldValue(fieldKey, parameterValue);
          }
        }
        _ref1 = request.files;
        for (parameterKey in _ref1) {
          parameterValue = _ref1[parameterKey];
          fieldKey = parameterKey.replace(this.name + '_', '');
          if (__indexOf.call(this.fields, fieldKey) >= 0) {
            this.setFieldValue(fieldKey, parameterValue);
          }
        }
        return this;
      };

      Model.prototype.validate = function(allErrors) {
        if (allErrors == null) {
          allErrors = false;
        }
        return new Promise((function(_this) {
          return function(resolve, reject) {
            var e, modelIsValid;
            _this.errorMessages = [];
            modelIsValid = true;
            try {
              if (_this._joiValidate(allErrors) === false) {
                modelIsValid = false;
              }
              return Promise.all(_this._customValidate(allErrors).concat(_this._fileValidate(allErrors))).then(function(results) {
                _.remove(results, function(result) {
                  return result === true;
                });
                if (results.length > 0) {
                  modelIsValid = false;
                }
                return resolve({
                  valid: modelIsValid,
                  model: _this,
                  values: _this.getValues(),
                  errors: _this.getAllErrors()
                });
              });
            } catch (_error) {
              e = _error;
              return reject(e);
            }
          };
        })(this));
      };

      Model.prototype.addError = function(field, errorMessage, allErrors) {
        if (this.errorMessages[field] && this.errorMessages[field].length > 0 && allErrors) {
          return this.errorMessages[field].push(errorMessage);
        } else {
          return this.errorMessages[field] = [errorMessage];
        }
      };

      Model.prototype.getAllErrors = function() {
        return this.errorMessages;
      };

      Model.prototype.getErrorsForField = function(field) {
        if (this.errorMessages[field] != null) {
          return this.errorMessages[field];
        } else {
          return [];
        }
      };

      Model.prototype.getLabelText = function(field) {
        if (this.labels[field] != null) {
          return this.labels[field];
        } else {
          return _.str.humanize(field);
        }
      };

      Model.prototype.getContainerClasses = function(field, additionalClasses, glue) {
        var classes;
        if (_.indexOf(this.fields, field, 0) !== -1) {
          classes = [];
          if (additionalClasses != null) {
            classes = additionalClasses.split(' ');
          }
          if (this.errorMessages[field] != null) {
            classes.push('error');
          }
          if (classes.length) {
            if (glue != null) {
              return classes.join(glue);
            } else {
              return classes;
            }
          } else {
            return '';
          }
        } else {
          throw new Error("Field " + field + " Not Found In Model");
        }
      };

      Model.prototype.fieldIdentifier = function(field) {
        var fieldName;
        if (__indexOf.call(this.fields, field) >= 0) {
          fieldName = this.name + '_' + field;
          return fieldName;
        } else {
          throw new Error('Field Not Found In ' + this.name(' Model'));
        }
      };

      Model.prototype._joiValidate = function(allErrors) {
        var errorValue, errors, field, joiFields, label, result, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
        joiFields = {};
        _ref = this.fields;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          field = _ref[_i];
          if (this.joiValidators[field]) {
            joiFields[field] = this.getFieldValue(field);
          }
        }
        result = Braids.joi.validate(joiFields, this.joiValidators, {
          abortEarly: false
        });
        if (result === null) {
          return true;
        } else {
          errors = result.details;
          if (allErrors === true) {
            _ref1 = this.fields;
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              field = _ref1[_j];
              label = this.getLabelText(field);
              this.errorMessages[field] = _(errors).chain().filter({
                path: field
              }).flatten('message').map(function(errorString) {
                return _.str.capitalize(errorString.replace(field, label));
              }).value();
            }
          } else {
            _ref2 = this.fields;
            for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
              field = _ref2[_k];
              label = this.getLabelText(field);
              errorValue = _(errors).chain().filter({
                path: field
              }).pluck('message').map(function(errorString) {
                return _.str.capitalize(errorString.replace(field, label));
              }).first().value();
              if (errorValue != null) {
                this.errorMessages[field] = [errorValue];
              }
            }
          }
          return false;
        }
      };

      Model.prototype._customValidate = function(allErrors) {
        var field, promises, _i, _len, _ref;
        promises = [];
        _ref = this.fields;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          field = _ref[_i];
          if (allErrors || (this.errorMessages[field] == null)) {
            if (this.customValidators[field] != null) {
              if (typeof this.customValidators[field] === 'function') {
                promises.push(this._validateCustomFunction(field, this.customValidators[field], allErrors));
              } else if (this.customValidators[field] instanceof Array) {
                promises = promises.concat(this._validateArrayOfCustomValidators(allErrors, field));
              } else {
                throw new Error('Custom Validators Must Be A Function Or An Array Of Functions');
              }
            }
          }
        }
        return promises;
      };

      Model.prototype._validateArrayOfCustomValidators = function(allErrors, field) {
        var customValidatorArray, customValidatorFunction, promises, _i, _len;
        promises = [];
        customValidatorArray = this.customValidators[field];
        for (_i = 0, _len = customValidatorArray.length; _i < _len; _i++) {
          customValidatorFunction = customValidatorArray[_i];
          promises.push(this._validateCustomFunction(field, customValidatorFunction, allErrors));
        }
        return promises;
      };

      Model.prototype._validateCustomFunction = function(field, validationFunction, allErrors) {
        var fieldValue, label;
        label = this.getLabelText(field);
        fieldValue = this.getFieldValue(field);
        return validationFunction(fieldValue, this).then((function(_this) {
          return function(result) {
            var parsedErrorMessage;
            if (result !== true) {
              parsedErrorMessage = result.replace('{{label}}', label);
              _this.addError(field, parsedErrorMessage, allErrors);
              return false;
            } else {
              return true;
            }
          };
        })(this));
      };

      Model.prototype._fileValidate = function(allErrors) {
        var field, promises, _i, _len, _ref;
        promises = [];
        _ref = this.fields;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          field = _ref[_i];
          if (allErrors || (this.errorMessages[field] == null)) {
            if (this.fileValidators[field] != null) {
              promises.push(new this.fileValidators[field]().validate(field, this, allErrors));
            }
          }
        }
        return promises;
      };

      return Model;

    })();

    Braids.FileValidator = (function() {
      function FileValidator() {
        this.validate = __bind(this.validate, this);
      }

      FileValidator.prototype.required = false;

      FileValidator.prototype.maxFileSize = null;

      FileValidator.prototype.validMimeTypes = [];

      FileValidator.prototype.enforceMimeMatch = false;

      FileValidator.prototype.validate = function(field, model, allErrors) {
        return new Promise((function(_this) {
          return function(resolve) {
            var bytesAmount, errorString, fileObject, filePath, fileType, label, mimeType, overallResult, regexResult, uploadedMimeTypeResult, wildCardResult, wildcardValues, _i, _len, _ref, _ref1, _ref2;
            overallResult = true;
            fileObject = model[field];
            label = model.getLabelText(field);
            if (_this.required === true) {
              if ((fileObject == null) || fileObject.size === 0 || fileObject.name === '' || fileObject.originalFilename === '') {
                model.addError(field, "" + label + " is a required field");
                overallResult = false;
                if (allErrors !== true) {
                  resolve(overallResult);
                }
              }
            }
            if (_this.validMimeTypes && _this.validMimeTypes.length > 0) {
              wildCardResult = false;
              wildcardValues = [];
              _ref = _this.validMimeTypes;
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                mimeType = _ref[_i];
                regexResult = mimeTypeWildcardRegex.exec(mimeType);
                if (regexResult && (regexResult.length === 3)) {
                  wildcardValues.push(regexResult[1]);
                }
              }
              if (wildcardValues.length > 0) {
                uploadedMimeTypeResult = mimeTypeRegex.exec(fileObject.type);
                if (uploadedMimeTypeResult && (uploadedMimeTypeResult.length === 3)) {
                  if (_ref1 = uploadedMimeTypeResult[1], __indexOf.call(wildcardValues, _ref1) >= 0) {
                    wildCardResult = true;
                  }
                }
              }
              if ((_ref2 = fileObject.type, __indexOf.call(_this.validMimeTypes, _ref2) < 0) && wildCardResult === false) {
                errorString = ("" + label + " must be one of the following file types: ") + (_this.validMimeTypes.join(", "));
                model.addError(field, errorString, allErrors);
                overallResult = false;
                if (allErrors !== true) {
                  resolve(overallResult);
                }
              }
            }
            if (_this.maxFileSize) {
              bytesAmount = sizeInBytes(_this.maxFileSize);
              if (fileObject.size > bytesAmount) {
                errorString = ("" + label + " is too large - it must be smaller than ") + (humanizeBytes(bytesAmount));
                model.addError(field, errorString, allErrors);
                overallResult = false;
                if (allErrors !== true) {
                  resolve(overallResult);
                }
              }
            }
            if (_this.enforceMimeMatch) {
              filePath = fileObject.path;
              fileType = fileObject.type.trim();
              return execPromisified("file " + filePath + " --mime-type --brief -r").then(function(results) {
                var fileResult;
                fileResult = results[0].trim();
                if (fileType !== fileResult) {
                  errorString = "The file you uploaded is actually the type of " + fileResult + ", but the extension is of type " + fileType + " - please correct this and try uploading again";
                  model.addError(field, errorString, allErrors);
                  overallResult = false;
                }
                return resolve(overallResult);
              });
            } else {
              return resolve(overallResult);
            }
          };
        })(this));
      };

      return FileValidator;

    })();

    Braids.Model.Extend = Braids.Model.extend = Braids.FileValidator.Extend = Braids.FileValidator.extend = extend;

    return Braids;

  })();

  module.exports = Braids;

}).call(this);
